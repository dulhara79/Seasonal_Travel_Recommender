"""Responsible AI validation and enrichment utilities.

This module provides functions to validate and enrich trip_plan responses
so they comply with the project's Responsible AI expectations:
- Ensure packing list is present and reasonably complete
- Attach per-location reasons and provenance when available
- Add a `responsible_ai` block describing provenance, checks performed,
  and any missing/confidence issues.

The functions are intentionally conservative and operate on plain dicts so
they can be called from the API layer without requiring Pydantic models.
"""
from typing import Dict, Any, List
import datetime


def _ensure_packing_list(plan: Dict[str, Any]) -> None:
    """Ensure `packing_list` exists and add minimal defaults if missing.

    This function mutates the plan in-place.
    """
    packing = plan.get("packing_list")
    if not packing:
        # Add a conservative, general-purpose packing list
        plan["packing_list"] = {
            "duration_days": None,
            "categories": [
                {"name": "Clothing", "items": ["Light shirts", "Light pants/shorts", "Underwear", "Sleepwear"]},
                {"name": "Toiletries", "items": ["Toothbrush", "Toothpaste", "sunscreen SPF 30+"]},
                {"name": "Health & Safety", "items": ["Basic first-aid kit", "Insect repellent"]},
                {"name": "Documents", "items": ["Passport/ID", "Travel insurance info"]},
            ],
            "notes": ["Packing list autogenerated due to missing agent output. Review for special activities."]
        }
    else:
        # Basic completeness checks: ensure categories and notes exist
        if "categories" not in packing or not isinstance(packing.get("categories"), list):
            packing["categories"] = []
        if "notes" not in packing or not isinstance(packing.get("notes"), list):
            packing["notes"] = []


def _append_location_reasons(plan: Dict[str, Any]) -> None:
    """Ensure `location_recommendations` or `locations_to_visit` include per-location reasons.

    If a downstream agent placed richer metadata into `location_recommendations`, keep it.
    Otherwise, add placeholder reasons prompting the system to expand them later.
    """
    rec = plan.get("location_recommendations")
    locations = plan.get("locations_to_visit") or []
    enriched = []

    if isinstance(rec, dict) and rec.get("recommended_locations"):
        # Prefer the agent-provided structured data
        for loc in rec.get("recommended_locations"):
            if isinstance(loc, dict):
                enriched.append(loc)
            else:
                enriched.append({"name": str(loc), "reason": "Recommended by location agent", "source_hints": []})
    else:
        # Build minimal structured items from `locations_to_visit`
        for name in locations:
            enriched.append({
                "name": name,
                "reason": f"Included because it is a notable point of interest in {plan.get('destination')}",
                "source_hints": []
            })

    # Attach the enriched list for transparency and also populate
    # `locations_to_visit` with structured entries so downstream callers
    # (and the frontend) have both a string list and a rich list.
    plan["location_recommendations_enriched"] = enriched

    # Normalize `locations_to_visit` to the enriched structured form
    # If original `locations_to_visit` was a list of strings, replace it with
    # the corresponding enriched dicts. If mapping cannot be done, keep names.
    if plan.get("locations_to_visit"):
        # Build structured entries in the same order as `enriched` if possible
        structured = []
        for e in enriched:
            structured.append({
                "name": e.get("name"),
                "reason": e.get("reason") or "Recommended by location agent",
                "source_hints": e.get("source_hints") or []
            })
        plan["locations_to_visit"] = structured
    else:
        # No original locations list: set to enriched names/objects
        plan["locations_to_visit"] = enriched


def _build_responsible_block(plan: Dict[str, Any], notes: List[str] = None) -> Dict[str, Any]:
    """Build a Responsible AI metadata block describing provenance and checks."""
    now = datetime.datetime.utcnow().isoformat() + "Z"
    block = {
        "timestamp": now,
        "provenance": {
            "agents": {
                "location_agent": bool(plan.get("location_recommendations")),
                "activity_agent": bool(plan.get("activity_recommendations")),
                "packing_agent": bool(plan.get("packing_list")),
                "summary_agent": bool(plan.get("summary")),
            }
        },
        "checks": {
            "packing_list_present": bool(plan.get("packing_list")),
            "locations_explained": bool(plan.get("location_recommendations_enriched")),
        },
        "notes": notes or []
    }
    return block


def enrich_trip_plan_response(response: Dict[str, Any]) -> Dict[str, Any]:
    """Main entry: validate and enrich the API response's `trip_plan`.

    Returns a new dict (may mutate input) that contains a `responsible_ai` block
    and additional transparency fields. Designed to be safe and idempotent.
    """
    if not isinstance(response, dict):
        return response

    trip = response.get("trip_plan")
    if not isinstance(trip, dict):
        return response

    notes = []

    # Packing list
    if not trip.get("packing_list"):
        notes.append("Packing list was missing and was autogenerated with conservative defaults.")
    _ensure_packing_list(trip)

    # Location reasons and provenance
    _append_location_reasons(trip)

    # If activities lack 'why' for suggestions, add placeholders
    activities = trip.get("activities") or []
    for day in activities:
        for sug in day.get("suggestions", []) if isinstance(day, dict) else []:
            if "why" not in sug or not sug.get("why"):
                sug["why"] = "Suggested by activity agent; no explicit rationale provided. Verify locally for safety and relevance."

    # Build the responsible block
    resp = _build_responsible_block(trip, notes=notes)
    trip["responsible_ai"] = resp

    # Also attach a top-level `responsible_ai` for the whole API response
    response["responsible_ai_enriched"] = {
        "applied_to": "trip_plan",
        "timestamp": resp["timestamp"],
        "summary": {
            "notes_added": len(notes) > 0,
            "notes": notes
        }
    }

    return response
